package week7;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/*
데이터를 가져올 때 파일, 표준입력, 데이터베이스, 앱, 네트워크에서 가져오는데 A라는 방법 하나만 알게된다면 다 처리할 수 있음. 그 A가 스트림이다.
1. 스트림을(A를) 연결
2. read를 통해 데이터를 읽어서 순차적으로 하나하나씩 넘겨옴/write를 쓰기도 함.
3. 닫기
<DB> ->JDBC라는 인터페이스를 통해서 SQL 기반의 쿼리 중심으로. 권한, 보안문제상 이유임.

앱   -   파일/콘솔/네트워크
InputStream이라는 파일이 빨대를 꽂는 순간 만들어짐. read로 읽어옴.
1. 기본 Stream(InputStream) 으로 연결한다.
2. 기능 Stream을 연결하여 기능적인 역할을 더한다.(옵션)
3. 스트림은 기본적으로 단방향적인 특징이 있음.->입력하는 스트림과 출력하는 스트림을 따로 뚫어야 한다는 소리임
    출력의 경우-outputStream, 입력의 경우-inputStream이라고 함
4. 통신데이터는 byte단위, 문자(character) 단위 두가지로 나뉨.
    기본스트림은 무조건 byte. 문자통신을 하기 위해 기능적 스트림을 추가로 끼워서 사용.
    byte 단위는 스트림 객체를 씀. 출력의 경우-outputStream, 입력의 경우-inputStream을 사용 -> 스트림을 사용하면 무조건 바이트 단위라고 생각하면 됨.
    문자단위는 writer, reader로 처리
            문자 단위로 저장하려면 encoding을 알아야 함.
            (ABC abc 123)=1byte=8bit로 표현 가능함.
            (가나다 한자 기호)들을 저장하는 방식이 인코딩마다 다름. 얘네는 1바이트로 표현이 안돼서 멀티바이트로 해줘야댐. 근데 그 방식이 인코딩마다 달라짐.
            -euc-kr -MS949

빨대꽂는법
>>스트림(Stream): 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
        -데이터 처리 연산: 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
                       예를 들어 filter, map, reduce, find, match, sort 등으로 데이터를 조작할 수 있다.
                       스트림 연산은 데이터를 순차적으로 또는 병렬로 실행할 수 있다.
        -소스: 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
              정렬된 컬렌션으로 스트림을 생성하면 정렬이 그대로 유지된다.
              즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.
        -연속된 요소: 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
                   컬렉션은 자료구조이므로 컬렉션에서는 시간과 공간의 복잡성과 관련된 요소 저장(ex: add) 및 접근(ex: get) 연산이 주를 이룬다.
                   반면, 스트림은 filter, map, sorted처럼 표현 계산식이 주를 이룬다. 정리하면, 컬렉션의 주제는 데이터이고, 스트림의 주제는 계산이다.
        -특징
            -파이프 라이닝: 부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다.
                        그 덕분에 layziness(게으름), short-circuiting(쇼트서킷) 같은 최적화도 얻을 수 있다.
                        연산 파이프라인은 데이터 소스에 적용하는 데이터베이스 질의와 비슷하다.
            -내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

>>컬렉션과 스트림:
    데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이
        -컬렉션: 우리가 아는 DVD와 비슷함. 영상 전체 데이터를 CD에 모두 담고 있다.
               컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료 구조다.
               즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.

        -스트림: 스트리밍 서비스와 비슷함. 사용자가 필요로 하는 몇 부분만 미리 내려받는다.
               스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조이다.
               사용자가 요청하는 값만 추출하는 것이 스트림의 핵심.
        -차이점: 외부 반복과 내부 반복
            -컬렉션을 사용하려면 사용자가 직접 요소를 반복(ex: for-each문)해야 하는데 이를 외부 반복이라 한다.
             반면 스트림은 반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장해 주는 내부 반복을 사용한다.

>>스트림 연산: 중간연산, 최종 연산 두가지로 나뉨
 */
public class Stream {
    public static void main(String[] args) {

        String[] array = { "안녕하세요", "맑음", "cloud", "구름", "달빛", "눈" };
        Set<String> set = Arrays.asList(array) // array를 List로 변형하고
                .stream() // 1. stream 생성
                .filter(e -> e.startsWith("cl")) // 2. 중개 연산 - cl로 시작하는 단어
                .map(String::toUpperCase) // 2. 중개 연산 - 대문자로 변환
                .collect(Collectors.toSet()); // 3. 최종 연산 - 중개 연산을 통해 가공된 stream을 모아준다.
        set.forEach(e -> System.out.println(e));

        System.out.println("==============================================");

        String[] array2 = { "수성", "금성", "지구", "화성", "목성" };
        List<String> list = Arrays.asList(array2) // array를 List로 변형하고
                .stream() // 1. stream 생성
                .sorted() // 2. 중개 연산 - 정렬(오름차순)
//				.sorted(Comparator.reverseOrder()) // 2. 중개 연산 - 정렬(내림차순)
                .filter(e -> e.startsWith("금")) // 2. 중개 연산 - 금으로 시작하는 단어
                .map(e -> e = "혜성") // 2. 중개 연산 - 금으로 시작하는 단어를 혜성으로 변경
                .collect(Collectors.toList()); // 3. 최종 연산 - 중개 연산을 통해 가공된 stream을 모아준다.
        list.forEach(e -> System.out.println(e));

        /////////////////// 출력결과 ////////////////////
        // CLOUD
        // ==============================================
        // 혜성
    }
}
